{{ define "object/common" }}
package {{ .Package }}

type fieldPair struct {
  Name string
  Value interface{}
}
{{ end }}

{{ define "object" }}
{{- $objectName := .Name -}}
package {{ .Package }}

{{- if hasTemplate "ext/object/header" }}
  {{- runTemplate "ext/object/header" $ }}
{{- end }}

{{ comment .Comment .Name }}
type {{ $objectName }} struct {
  mu sync.RWMutex
{{- range $i, $field := .Fields }}
  {{ $field.GetUnexportedName }} {{ $field.GetType.GetIndirectType }}
{{- end }}
  extra map[string]interface{}
}

// These constants are used when the JSON field name is used.
// Their use is not strictly required, but certain linters
// complain about repeated constants, and therefore internally
// this used throughout
const (
{{- range $i, $field := .Fields }}
  {{- if $field.GetExtension }}{{ continue }}{{ end }}
  {{ $field.GetKeyName $ }} = {{ $field.GetJSON | printf "%q" }}
{{- end }}
)

// Get retrieves the value associated with a key
func (v *{{ $objectName }}) Get(key string, dst interface{}) error {
  v.mu.RLock()
  defer v.mu.RUnlock()
  switch key {
{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
  {{- if $field.GetExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
    if val := v.{{ $field.GetUnexportedName }}; val != nil {
      return blackmagic.AssignIfCompatible(dst, {{ if $type.GetImplementsGet }}val.Get(){{ else if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }})
    }
{{- end }}
  default:
    if v.extra != nil {
      val, ok := v.extra[key]
      if ok {
        return blackmagic.AssignIfCompatible(dst, val)
      }
    }
  }
  return fmt.Errorf(`no such key %q`, key)
}

// Set sets the value of the specified field. The name must be a JSON
// field name, not the Go name
func (v *{{ $objectName }}) Set(key string, value interface{}) error {
  v.mu.Lock()
  defer v.mu.Unlock()
  switch key {
{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
  {{- if $field.GetExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
  {{- if $type.GetImplementsAccept }}
    var object {{ $rawType }}
    if err := object.Accept(value); err != nil {
      return fmt.Errorf(`failed to accept value: %w`, err)
    }
    {{- if (eq $rawType $indirectType) }}
    v.{{ $field.GetUnexportedName }} = object
    {{- else }}
    v.{{ $field.GetUnexportedName }} = &object
    {{- end }}
  {{- else }}
    converted, ok := value.({{ $rawType }})
    if !ok {
      return fmt.Errorf(`expected value of type {{ $rawType }} for field {{ $field.GetJSON }}, got %T`, value)
    }
    {{- if (eq $rawType $indirectType) }}
    v.{{ $field.GetUnexportedName }} = converted
    {{- else }}
    v.{{ $field.GetUnexportedName }} = &converted
    {{- end }}
  {{- end }}
{{- end }}
  default:
    if v.extra == nil {
      v.extra = make(map[string]interface{})
    }
    v.extra[key] = value
  }
  return nil
}

{{- if .GenerateHasMethods }}
{{- range $i, $field := .Fields }}
{{- if $field.GetExtension }}{{ continue }}{{ end }}
func (v *{{ $objectName }}) Has{{ $field.GetName }}() bool {
  v.mu.RLock()
  defer v.mu.RUnlock()
  return v.{{ $field.GetUnexportedName }} != nil
}

{{ end }}
{{- end }}

{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
{{- if $field.GetExtension }}{{ continue }}{{ end }}
{{ comment $field.GetComment $field.GetName }}
func (v *{{ $objectName }}) {{ $field.GetName }}() {{ $type.GetUserFacingType }} {
  v.mu.RLock()
  defer v.mu.RUnlock()
  if val := v.{{ $field.GetUnexportedName }}; val != nil {
    return {{ if $type.GetImplementsGet }}val.Get(){{ else if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }}
  }
  return {{ $type.GetZeroVal }}
}
{{ end }}

// Remove removes the value associated with a key
func (v *{{ $objectName }}) Remove(key string) error {
  v.mu.Lock()
  defer v.mu.Unlock()

  switch key {
{{- range $i, $field := .Fields }}
  {{- if $field.GetExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
    v.{{ $field.GetUnexportedName }} = nil
{{- end }}
  default:
    delete(v.extra, key)
  }

  return nil
}

func (v *{{ $objectName }}) makePairs() []*fieldPair {
  pairs := make([]*fieldPair, 0, {{ len .Fields }})
{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
  {{- if $field.GetExtension }}{{ continue }}{{ end }}
  if val := v.{{ $field.GetUnexportedName }}; {{ if (or $type.GetIsMap $type.GetIsSlice) }}len(val) > 0 {{ else }}val != nil{{ end }} {
    pairs = append(pairs, &fieldPair{Name: {{ $field.GetKeyName $ }}, Value: {{ if $type.GetImplementsGet }}val.Get(){{ else if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }}})
  }
{{- end }}

  for key, val := range v.extra {
    pairs = append(pairs, &fieldPair{Name: key, Value: val})
  }

  sort.Slice(pairs, func(i, j int) bool {
    return pairs[i].Name < pairs[j].Name
  })
  return pairs
}

{{ if .GenerateMethod "object.MarshalJSON" -}}
// MarshalJSON serializes {{ $objectName }} into JSON.
// All pre-declared fields are included as long as a value is
// assigned to them, as well as all extra fields. All of these
// fields are sorted in alphabetical order.
func (v *{{ $objectName }}) MarshalJSON() ([]byte, error) {
  pairs := v.makePairs()

  var buf bytes.Buffer
  enc := json.NewEncoder(&buf)
  buf.WriteByte('{')
  for i, pair := range pairs {
    if i > 0 {
      buf.WriteByte(',')
    }
    if err := enc.Encode(pair.Name); err != nil {
      return nil, fmt.Errorf(`failed to encode map key name: %w`, err)
    }
    buf.WriteByte(':')
    if err := enc.Encode(pair.Value); err != nil {
      return nil, fmt.Errorf(`failed to encode map value for %q: %w`, pair.Name, err)
    }
  }
  buf.WriteByte('}')
  return buf.Bytes(), nil
}
{{ end -}}

{{ if .GenerateMethod "object.UnmarshalJSON" -}}
// UnmarshalJSON deserializes a piece of JSON data into {{ $objectName }}.
//
// Pre-defined fields must be deserializable via "encoding/json" to their
// respective Go types, otherwise an error is returned.
//
// Extra fields are stored in a special "extra" storage, which can only
// be accessed via `Get()` and `Set()` methods.
func (v *{{ $objectName }}) UnmarshalJSON(data []byte) error {
  v.mu.Lock()
  defer v.mu.Unlock()

{{- range $i, $field := .Fields }}
{{- if $field.GetExtension }}{{ continue }}{{ end }}
  v.{{ $field.GetUnexportedName }} = nil
{{- end }}

  dec := json.NewDecoder(bytes.NewReader(data))

LOOP:
  for {
    tok, err := dec.Token()
    if err != nil {
      return fmt.Errorf(`error reading JSON token: %w`, err)
    }
    switch tok := tok.(type) {
    case json.Delim:
      if tok == '}' { // end of object
        break LOOP
      }
      // we should only get into this clause at the very beginning, and just once 
      if tok != '{' {
        return fmt.Errorf(`expected '{', but got '%c'`, tok)
      }
    case string:
      switch tok {
{{- range $i, $field := .Fields }}
{{- if $field.GetExtension }}{{ continue }}{{ end }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
      case {{ $field.GetKeyName $ }}:
        var val {{ $rawType }}
        if err := dec.Decode(&val); err != nil {
          return fmt.Errorf(`failed to decode value for %q: %w`, {{ $field.GetKeyName $ }}, err)
        }
  {{- if (eq $rawType $indirectType) }}
        v.{{ $field.GetUnexportedName }} = val
  {{- else }}
        v.{{ $field.GetUnexportedName }} = &val
  {{- end }}
{{- end }}
      default:
        var val interface{}
	if err := dec.Decode(&val); err != nil {
	  return fmt.Errorf(`failed to decode value for %q: %w`, tok, err)
	}
	if v.extra == nil {
	  v.extra = make(map[string]interface{})
	}
        v.extra[tok] = val
      }
    }
  }
  return nil
}
{{ end -}}

{{- if .GenerateBuilders }}
{{ runTemplate "object/builder" $ }}
{{- end }}
{{- if hasTemplate "ext/object/footer" }}
  {{- runTemplate "ext/object/footer" $ }}
{{- end }}
{{- end }}
