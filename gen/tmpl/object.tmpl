{{ define "files/per-run/sketch.go" }}
// Generated by "sketch" utility. DO NOT EDIT
package {{ .Package }}

import (
  "encoding/json"
  "fmt"
)

type fieldPair struct {
  Name string
  Value interface{}
}

func defaultDecodeExtra(name string, dec *json.Decoder, dst interface{}) error {
  if err := dec.Decode(dst); err != nil {
    return fmt.Errorf(`failed to decode value for %q: %w`, name, err)
  }
  return nil
}
{{ end }}

{{ define "files/per-object/object.go" }}
{{- runTemplate "object/header" $ }}
{{- runTemplate "object/struct" $ }}
{{- $objectName := .Name -}}

// These constants are used when the JSON field name is used.
// Their use is not strictly required, but certain linters
// complain about repeated constants, and therefore internally
// this used throughout
const (
{{- range $i, $field := .Fields }}
  {{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  {{ $field.GetKeyName $ }} = {{ $field.GetJSON | printf "%q" }}
{{- end }}
)

{{ if .GenerateMethod "object.method.Get" -}}
// Get retrieves the value associated with a key
func (v *{{ $objectName }}) Get(key string, dst interface{}) error {
  v.mu.RLock()
  defer v.mu.RUnlock()
  return v.getNoLock(key, dst, false)
}
{{- /* end .GenerateMethod "object.method.Get" */ -}}{{ end }}

{{ if .GenerateMethod "object.method.getNoLock" -}}
// getNoLock is a utility method that is called from Get, MarshalJSON, etc, but
// it can be used from user-supplied code. Unlike Get, it avoids locking for
// each call, so the user needs to explicitly lock the object before using,
// but otherwise should be faster than sing Get directly
func (v *{{ $objectName }}) getNoLock(key string, dst interface{}, raw bool) error {
  switch key {
{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
  {{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
    if val := v.{{ $field.GetUnexportedName }}; val != nil {
    {{- if $type.GetImplementsGet }}
      if raw {
        return blackmagic.AssignIfCompatible(dst, {{ if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }})
      }
      return blackmagic.AssignIfCompatible(dst, val.Get())
    {{- else }}
      return blackmagic.AssignIfCompatible(dst, {{ if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }})
    {{- end }}
    }
{{- end }}
  default:
    if v.extra != nil {
      val, ok := v.extra[key]
      if ok {
        return blackmagic.AssignIfCompatible(dst, val)
      }
    }
  }
  return fmt.Errorf(`no such key %q`, key)
}
{{- end }}

{{- if .GenerateMethod "object.method.Set" }}
// Set sets the value of the specified field. The name must be a JSON
// field name, not the Go name
func (v *{{ $objectName }}) Set(key string, value interface{}) error {
  v.mu.Lock()
  defer v.mu.Unlock()
  switch key {
{{- range $i, $field := .Fields }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
  {{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
  {{- if $type.GetImplementsAccept }}
    var object {{ $rawType }}
    if err := object.Accept(value); err != nil {
      return fmt.Errorf(`failed to accept value: %w`, err)
    }
    {{- if (eq $rawType $indirectType) }}
    v.{{ $field.GetUnexportedName }} = object
    {{- else }}
    v.{{ $field.GetUnexportedName }} = &object
    {{- end }}
  {{- else }}
    converted, ok := value.({{ $rawType }})
    if !ok {
      return fmt.Errorf(`expected value of type {{ $rawType }} for field {{ $field.GetJSON }}, got %T`, value)
    }

    {{- if (eq $rawType $indirectType) }}
    v.{{ $field.GetUnexportedName }} = converted
    {{- else }}
    v.{{ $field.GetUnexportedName }} = &converted
    {{- end }}
  {{- end }}
{{- end }}
  default:
    if v.extra == nil {
      v.extra = make(map[string]interface{})
    }
    v.extra[key] = value
  }
  return nil
}
{{ end }}

{{- if .GenerateMethod "object.method.Has" }}
// Has returns true if the field specified by the argument has been populated.
// The field name must be the JSON field name, not the Go-structure's field name.
func (v *{{ $objectName }}) Has(name string) bool {
  switch name {
{{- range $i, $field := .Fields }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
    return v.{{ $field.GetUnexportedName }} != nil
{{- end }}
  default:
    if v.extra != nil {
      if _, ok := v.extra[name]; ok {
        return true
      }
    }
    return false
  }
}
{{- /* end "object.method.Has" */ -}}{{ end }}

{{- if $.GenerateMethod "object.method.Keys" }}
// Keys returns a slice of string comprising of JSON field names whose values
// are present in the object. 
func (v *{{ $objectName }}) Keys() []string {
  keys := make([]string, 0, {{ (len .Fields) }})
{{- range $i, $field := .Fields }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  if v.{{ $field.GetUnexportedName }} != nil {
    keys = append(keys, {{ $field.GetKeyName $ }})
  }
{{- /* end range */ -}}{{- end }}

  if len(v.extra) > 0 {
    for k := range v.extra {
      keys = append(keys, k)
    }
  }
  sort.Strings(keys)
  return keys
}
{{- /* end "object.method.Keys" */ -}}{{ end }}

{{- range $i, $field := .Fields }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
{{- if $.GenerateMethod ($field.GetName | printf "object.method.Has%s") }}
// Has{{ $field.GetName }} returns true if the field `{{ $field.GetJSON }}` has been populated
func (v *{{ $objectName }}) Has{{ $field.GetName }}() bool {
  v.mu.RLock()
  defer v.mu.RUnlock()
  return v.{{ $field.GetUnexportedName }} != nil
}
{{- /* end object.method.Has% */ -}}{{ end }}
{{- /* end range */ -}}{{ end }}

{{- range $i, $field := .Fields }}
{{ if $.GenerateMethod ($field.GetName | printf "object.method.%s") }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
{{ comment $field.GetComment $field }}
func (v *{{ $objectName }}) {{ $field.GetName }}() {{ $type.GetApparentType }} {
  v.mu.RLock()
  defer v.mu.RUnlock()
  if val := v.{{ $field.GetUnexportedName }}; val != nil {
    return {{ if $type.GetImplementsGet }}val.Get(){{ else if (ne $rawType $indirectType) }}*val{{ else }}val{{ end }}
  }
  return {{ $type.GetZeroVal }}
}
{{- /* end "object.method.%s" */ -}}{{ end }}
{{- /* end range */ -}}{{ end }}

{{- if .GenerateMethod "object.method.Remove" }}
// Remove removes the value associated with a key
func (v *{{ $objectName }}) Remove(key string) error {
  v.mu.Lock()
  defer v.mu.Unlock()

  switch key {
{{- range $i, $field := .Fields }}
  {{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  case {{ $field.GetKeyName $ }}:
    v.{{ $field.GetUnexportedName }} = nil
{{- end }}
  default:
    delete(v.extra, key)
  }

  return nil
}
{{- end }}

{{ if .GenerateMethod "object.method.Clone" -}}
func (v *{{ $objectName }}) Clone() ({{ .CloneResultType }}, error) {
  v.mu.RLock()
  defer v.mu.RUnlock()
  return &{{ $objectName }}{
{{- range $i, $field := .Fields }}
    {{ $field.GetUnexportedName }}: v.{{ $field.GetUnexportedName }},
{{- end }}
  }, nil
}
{{ end }}

{{ if .GenerateMethod "object.method.MarshalJSON" -}}
// MarshalJSON serializes {{ $objectName }} into JSON.
// All pre-declared fields are included as long as a value is
// assigned to them, as well as all extra fields. All of these
// fields are sorted in alphabetical order.
func (v *{{ $objectName }}) MarshalJSON() ([]byte, error) {
  v.mu.RLock()
  defer v.mu.RUnlock()

  var buf bytes.Buffer
  enc := json.NewEncoder(&buf)
  buf.WriteByte('{')
  for i, k := range v.Keys() {
    var val interface{}
    if err := v.getNoLock(k, &val, true); err != nil {
      return nil, fmt.Errorf(`failed to retrieve value for field %q: %w`, k, err)
    }

    if i > 0 {
      buf.WriteByte(',')
    }
    if err := enc.Encode(k); err != nil {
      return nil, fmt.Errorf(`failed to encode map key name: %w`, err)
    }
    buf.WriteByte(':')
    if err := enc.Encode(val); err != nil {
      return nil, fmt.Errorf(`failed to encode map value for %q: %w`, k, err)
    }
  }
  buf.WriteByte('}')
  return buf.Bytes(), nil
}
{{ end -}}

{{ if .GenerateMethod "object.method.decodeExtraField" }}
func (v *{{ $objectName }}) decodeExtraField(name string, dec *json.Decoder, dst interface{}) error {
  if err := dec.Decode(dst); err != nil {
    return fmt.Errorf(`failed to decode value for %q: %w`, name, err)
  }
  return nil
}
{{- end }}

{{ if .GenerateMethod "object.method.UnmarshalJSON" -}}
// UnmarshalJSON deserializes a piece of JSON data into {{ $objectName }}.
//
// Pre-defined fields must be deserializable via "encoding/json" to their
// respective Go types, otherwise an error is returned.
//
// Extra fields are stored in a special "extra" storage, which can only
// be accessed via `Get()` and `Set()` methods.
func (v *{{ $objectName }}) UnmarshalJSON(data []byte) error {
  v.mu.Lock()
  defer v.mu.Unlock()

{{- range $i, $field := .Fields }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
  v.{{ $field.GetUnexportedName }} = nil
{{- end }}

  dec := json.NewDecoder(bytes.NewReader(data))
  var extra map[string]interface{}

LOOP:
  for {
    tok, err := dec.Token()
    if err != nil {
      return fmt.Errorf(`error reading JSON token: %w`, err)
    }
    switch tok := tok.(type) {
    case json.Delim:
      if tok == '}' { // end of object
        break LOOP
      }
      // we should only get into this clause at the very beginning, and just once 
      if tok != '{' {
        return fmt.Errorf(`expected '{', but got '%c'`, tok)
      }
    case string:
      switch tok {
{{- range $i, $field := .Fields }}
{{- if $field.GetIsExtension }}{{ continue }}{{ end }}
{{- $type := $field.GetType }}
{{- $rawType := $type.GetName }}
{{- $indirectType := $type.GetIndirectType }}
      case {{ $field.GetKeyName $ }}:
        var val {{ $rawType }}
        if err := dec.Decode(&val); err != nil {
          return fmt.Errorf(`failed to decode value for %q: %w`, {{ $field.GetKeyName $ }}, err)
        }
  {{- if (eq $rawType $indirectType) }}
        v.{{ $field.GetUnexportedName }} = val
  {{- else }}
        v.{{ $field.GetUnexportedName }} = &val
  {{- end }}
{{- end }}
      default:
        var val interface{}
        if err := v.decodeExtraField(tok, dec, &val); err != nil {
          return fmt.Errorf(`failed to decode value for %q: %w`, tok, err)
        }
        if extra == nil {
          extra = make(map[string]interface{})
        }
        extra[tok] = val
      }
    }
  }

  if extra != nil {
    v.extra = extra
  }
  return nil
}
{{ end -}}

{{- runTemplate "object/builder" $ }}

{{ runTemplate "object/footer" $ }}
{{- end }}

{{ define "object/header" }}
{{- $objectName := .Name -}}
// Generated by "sketch" utility. DO NOT EDIT
package {{ .Package }}

{{ runTemplate "object/imports" $ }}

{{- if hasTemplate "ext/object/header" }}
  {{- runTemplate "ext/object/header" $ }}
{{- end }}
{{ end }}

{{ define "object/footer" }}
{{- if hasTemplate "ext/object/footer" }}
  {{- runTemplate "ext/object/footer" $ }}
{{- end }}
{{ end }}

{{ define "object/struct" }}
{{- $objectName := .Name -}}
{{ comment .Comment $ }}
type {{ $objectName }} struct {
  mu sync.RWMutex
{{- range $i, $field := .Fields }}
  {{ $field.GetUnexportedName }} {{ $field.GetType.GetIndirectType }}
{{- end }}
  extra map[string]interface{}
}
{{ end }}

{{ define "object/imports" }}
import (
{{- range $i, $pkg := .Imports }}
  {{ $pkg | printf "%q" }}
{{- end }}
)
{{ end }}
